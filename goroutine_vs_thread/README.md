#### goroutine vs thread 

```
发起http网络请求,网络请求属于被go特殊处理的netpoll操作(底层结合了linux的epoll及socket等),它不同于普通syscall那种操作,是不会导致线程阻塞的!
无论go还是python,http网络请求类的io操作都是可以做到N:1的!! 而http网络请求类io操作就是最常见的协程应用场景.
```

```
http网络请求的io操作go并没有线性增加线程数量.这点python也做到了,tornado/gevent的效果:单线程N协程.
本例中的1000个http网络请求这样的操作,只使用了10个线程.
```

```
无论怎样,go的协程之于python的协程,最大的好处至少是: 
从开发写代码来说,go替你打包了调度器的协程与线程映射细节,你只需要关心产品的并发业务逻辑开发即可！
至少在并发程序编写这块,go的确大大的提高了开发效率,提高了生产效率,这就是它的优点.所以在并发需求的程序中应当优先采用.
```

```
实际上,python的io型也不是1:1,也可以是M:1 => 在tornado和gevent中,N个http网络请求的协程也只使用了一个单线程的.只是有些比如访问mysql的操作,
本质上虽然是http访问,但是却没有人使用AsyncHttpClient来为mysql写这个异步client(需要按照mysql协议写http数据交互解析这些事),
需要自己写.这个就不方便了...效率低,造轮子.而go里面这些都有了,拿来就用,所以说生产效率高.
```


```
但是,无论python或go,有几种操作的确是协程1:1单独占用线程的:
  1.系统调用类的,(具体哪些操作呢?比如文件读写?反正网络io不是.)
  2.调用C等外部库的
  3.

综上: python/go协程最合适的应用场景应该是: 网络io型的程序.例如每个协程里发起http请求这种的,这样协程之于线程的优点才体现出来.
      否则1:1场景下其实底层还是开了那么多线程的话,不就还是和多线程一样了么...

技术都会有优点和缺点,它们有不同的应用场景,没有最好的最差的.在于架构师充分的了解和选用.所谓合脚的鞋子才是最好的鞋子.道理如是.
```

