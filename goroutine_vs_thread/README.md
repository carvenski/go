#### goroutine vs thread 

```
发起http网络请求,网络请求属于被go特殊处理的netpoll操作(底层结合了linux的epoll及socket等),它不同于普通syscall那种操作,是不会导致线程阻塞的!
无论go还是python,http网络请求类的io操作都是可以做到N:1的!! 而http网络请求类io操作就是最常见的协程应用场景.
```

```
http网络请求的io操作go并没有线性增加线程数量.这点python也做到了,tornado/gevent的效果:单线程N协程.
本例中的1000个http网络请求这样的操作,只使用了10个线程.
```

```
系统启动时，会启动一个独立的后台线程（不在Goroutine的调度线程池里），启动netpoll的轮询。
当有Goroutine发起网络请求时，网络库会将fd（文件描述符）和pollDesc（用于描述netpoll的结构体，包含因为读/写这个fd而阻塞的Goroutine）关联起来，
然后调用runtime.gopark方法，挂起当前的Goroutine。
当后台的netpoll轮询获取到epoll（linux环境下）的event，会将event中的pollDesc取出来，找到关联的阻塞Goroutine，并进行恢复。
可以看出和python的协程+epoll+socket那一套是一样的原理,go全都封装好了,让你用起来很简单.
```

```
无论怎样,go的协程之于python的协程,最大的好处至少是: 
从开发写代码来说,go替你打包了调度器的协程与线程映射细节,你只需要关心产品的并发业务逻辑开发即可！
至少在并发程序编写这块,go的确大大的提高了开发效率,提高了生产效率,这就是它的优点.所以在并发需求的程序中应当优先采用.
```

```
实际上,python的io型也不是1:1,也可以是M:1 => 在tornado和gevent中,N个http网络请求的协程也只使用了一个单线程的.只是有些比如访问mysql的操作,
本质上虽然是http访问,但是却没有人使用AsyncHttpClient来为mysql写这个异步client(需要按照mysql协议写http数据交互解析这些事),
需要自己写.这个就不方便了...效率低,造轮子.而go里面这些都有了,拿来就用,所以说生产效率高.
```


```
但是,无论python或go,有几种操作的确是协程1:1单独占用线程的:
  1.系统调用类的
  2.调用C等外部库的
  3.普通的IO阻塞型,例如文件读写这种(要注意:网络IO不是,网络IO被go优化了,可以做到N:1)

综上: python/go协程最合适的应用场景应该是: 网络io型的程序.例如每个协程里发起http请求这种的,这样协程之于线程的优点才体现出来.
      否则1:1场景下其实底层还是开了那么多线程的话,就和多线程一样了.所幸真实场景下还是网络IO型的居多的,可以做到N:1.

技术都会有优点和缺点,它们有不同的应用场景,没有最好的最差的.在于架构师充分的了解和选用.所谓合脚的鞋子才是最好的鞋子.道理如是.
```

