
#### goroutine抢占式调度

goroutine本来是设计为协程形式，但是随着调度器的实现越来越成熟，Go在1.2版中开始引入比较初级的抢占式调度。

##### 从一个bug说起
如果使用多个goroutine里面就一句fmt.Print('---1--2---3---4--'),会出现抢占控制台输出的情况,而不是完整地打印完一行才切换的(类似python多线程效果)
而tornado/gevent的协程是不会出现这种抢占控制台输出的情况的,这是和goroutine不同的一点,因为go带有初级的抢占式调度机制!!

Go在设计之初并没考虑将goroutine设计成抢占式的。用户负责让各个goroutine交互合作完成任务。        
一个goroutine只有在涉及到加锁，读写通道或者主动让出CPU等操作时才会触发切换。         
垃圾回收器是需要stop the world的。如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine合作停下来，这会造成较长时间的等待时间。      
考虑一种很极端的情况，所有的goroutine都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。         
抢占式调度可以解决这种问题，在抢占式情况下，如果一个goroutine运行时间过长，它就会被剥夺运行权。           

##### 总体思路

引入抢占式调度，会对最初的设计产生比较大的影响，Go还只是引入了一些很初级的抢占，并没有像操作系统调度那么复杂，没有对goroutine分时间片，设置优先级等    
只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime会在后台有一个检测线程，它会检测这些情况，并通知goroutine执行调度。      
目前并没有直接在后台的检测线程中做处理调度器相关逻辑，只是相当于给goroutine加了一个“标记”，然后在它进入函数时才会触发调度。      
这么做应该是出于对现有代码的修改最小的考虑。   

##### sysmon

前面讲Go程序的初始化过程中有提到过，runtime开了一条后台线程，运行一个sysmon函数。      
这个函数会周期性地做epoll操作，同时它还会检测每个P是否运行了较长时间。       
如果检测到某个P状态处于Psyscall超过了一个sysmon的时间周期(20us)，并且还有其它可运行的任务，则切换P。       
如果检测到某个P的状态为Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。         
这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。       
目前这里只是尽最大努力送达，但并不保证收到消息的goroutine一定会执行调度让出运行权。        




